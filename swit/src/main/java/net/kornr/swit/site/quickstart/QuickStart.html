<html xmlns:wicket="http://wicket.apache.org/dtds.data/wicket-xhtml1.3-strict.dtd" >
<body>
   	<wicket:extend>

	<h1>Quick Start</h1>
	
	   Swit was designed with the developers' ease of use in mind. 
	   Just grab the latest release binaries, add the jar to your Wicket project, and you're ready. To implement your first visual sugar, follow the tutorials.

		<ul style="font-size: 1.1em;" class="tabs">
   			<li><a href="#">Introduction on Swit resources</a></li>
   			<li><a href="#">Creating your first buttons</a></li>
   			<li><a href="#">Borders can look good too</a></li>
   			<li><a href="#">Using Swit's layout managers</a></li>
   		</ul>
		
		<div class="panes">

			<!-- Introduction on resources -->
			<div>
			   	<h2>A few words on Resources</h2>
				
				As Swit is mainly about dynamically generating resources, you should have a good understanding on how Swit (and Wicket) manages it. 
				Before using a resource, be it a button, a border, or a layout, you have to register it with its resource manager. 
				Swit requires this step because most resources have a bunch of properties, and we don't want to pass all those properties in 
				the resource URL every time it's requested to the server. As a consequence, resources are attributed a unique id, and only this id is passed
				in the URL. Of course, there may be additional parameters to the URL for specific resources customization or configuration, but as a general
				rule, Swit only passes a numerical ID.
			   
			    For instance, to use a border, this is what you do:
			    
			    <ul>
			    	<li>Step 1: Create a rounded border generator, with the specified parameters, and registers it with its global manager.
			    		<div><tt>Long borderId = RoundedBorderMaker.register(20, 3.5f, Color.black, Color.white);</tt></div>
			    	</li>
			    	<li>Step 2: Use this id to create a border.
			    		<div><tt>Border border = new TableImageBorder("outer-border", borderId, Color.gray));</tt></div>
			    	</li>
			    </ul> 
			    
			    <div>
			    	Because of this resource registration step, as a general rule, you should never (except in a few very specific cases) add Swit 
			    	resources as standard class properties, but always as static members of the class. 
			    	There's two really annoying consequences of using resources as non-static data:
			    	<ol>
			    		<li>If your resources are non-static class members, they are generated again every time the class is instanciated. 
			    		It's like never having a cache for the resources. This may be an intented effect (for instance, that's what the 
			    		button generator on this site does), but most of the time it's most likely an error.
			    		</li>
			    		<li>As you need to register your resources before using them, they are stored in the global manager. If you register 
			    		a resource every time a page is created, in other words, every time there's a page view, you're going to get an out of memory exception.
			    		The button generator uses a specific resource cache of the resource manager, implemented as a slot-limited LRU cache.   
			    		</li> 
			    	</ol>
			    	
			    	All the exemples on this quickstart tutorial are using static members, just follow them if you're not sure.
		    	</div>
			</div>
		
			<!-- Introduction on buttons -->
			<div>
			   <div>
			   		<h2>Programmatically creating buttons</h2>
			   		
			   		The design goal for the button generation engine was "make it a piece of cake". So here it is, in short:
		
					<div wicket:id="button-example"></div>
					
					Although this one is pretty short, a lot happens: A button generator is created (in the static initializer), and the <tt>ButtonResource.getImage()</tt>
					method registers the button template and the text. The button is then created only when it is first requested by the browser. Note that Swit takes care of
					caching everything, and the button image is only created once, then reused until the application shuts down. When you start the application again, 
					the cache is empty, and all the images are generated again.
		
					<p>
						The previous example was using a button with the factory settings, but you'll want to customize it somewhat. Here is below a more sophisticated example. 
						As you can see, the initialization of the buttons happens in the 'static' class initialization, and thus is only done once.  
					</p>
					<div wicket:id="button-example2"></div>
			   </div>
			</div>


			<!-- Introduction on Borders -->
			<div>
			   <div>
			   		<h2>Using Swit's borders</h2>
			   
			   		Just like buttons, borders are resources dynamically generated by Swit, but also aggressively cached. 
			   		Images created to build the borders are also designed to be as reasonably small as possible.
			   		For instance, here is below the biggest image generated and used to create the border of this page:
			   		<div style="text-align:center;">
			   			<img wicket:id="border-example-image"/>
			   		</div>
			   		
			   		<p/>
			   		
			   			Note in the very simple example below that to obtain a border, two components are used: the graphics generator, <tt>RoundedBorderMaker</tt> 
			   			and a Wicket Border component, <tt>TableImageBorder</tt>, which uses a table markup and specific requests to the border generator.
			   			<div wicket:id="border-example1"></div>
			   		
			   		<p/>
			   			This second example demonstrates how to apply a shadow effect to a border: Just combine a normal border and the shadow border. 
			   			Combinability is the corner stone of the border system, as some borders need to be combines with other; you just can't create a shadow border 
			   			without first defining a basic border on which to apply the shadow.
			   			<div wicket:id="border-example2"></div>
			   </div>
			</div>
		
		
			<!-- Introduction on Borders -->
			<div>
				<h2>Layout Managers</h2>
				
				Sure, Wicket uses plain HTML, so it doesn't need layout manager, right ? Wrong, of course. Layout manager are just another name for a combination 
				of java code, html, and css, which is what Wicket does best.
				
				<p/>
				
				The main layout manager of Swit (and the only one as of today :-)) is the classical 3-column layout, adapted from the excellent articles found
				<a href="http://matthewjamestaylor.com/blog/perfect-multi-column-liquid-layouts"> here</a>.
				Don't be fooled but the name, the 3-column layout can manage 1, 2, or 3 columns.
				
				<p/>
				
				<div wicket:id="layout-example1"></div>
				
				<p/>
				
				Each column of the ThreeColumnLayout is defined by a property of the LayoutInfo object. If a side column is empty (ie. no component was added to it), 
				it is automatically hidden.  
	
				<p>
				Now, let's see an example were we have only a middle column and a left column that takes 33% of the parent width.
				<div wicket:id="layout-example2"></div>
			</div>		
				
		</div>
	   
	</wicket:extend>
	
</body>
</html>

